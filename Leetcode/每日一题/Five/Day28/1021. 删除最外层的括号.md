#### [1021. 删除最外层的括号](https://leetcode.cn/problems/remove-outermost-parentheses/)

难度简单203

有效括号字符串为空 `""`、`"(" + A + ")"` 或 `A + B` ，其中 `A` 和 `B` 都是有效的括号字符串，`+` 代表字符串的连接。

- 例如，`""`，`"()"`，`"(())()"` 和 `"(()(()))"` 都是有效的括号字符串。

如果有效字符串 `s` 非空，且不存在将其拆分为 `s = A + B` 的方法，我们称其为**原语（primitive）**，其中 `A` 和 `B` 都是非空有效括号字符串。

给出一个非空有效字符串 `s`，考虑将其进行原语化分解，使得：`s = P_1 + P_2 + ... + P_k`，其中 `P_i` 是有效括号字符串原语。

对 `s` 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 `s` 。

 

**示例 1：**

```
输入：s = "(()())(())"
输出："()()()"
解释：
输入字符串为 "(()())(())"，原语化分解得到 "(()())" + "(())"，
删除每个部分中的最外层括号后得到 "()()" + "()" = "()()()"。
```

**示例 2：**

```
输入：s = "(()())(())(()(()))"
输出："()()()()(())"
解释：
输入字符串为 "(()())(())(()(()))"，原语化分解得到 "(()())" + "(())" + "(()(()))"，
删除每个部分中的最外层括号后得到 "()()" + "()" + "()(())" = "()()()()(())"。
```

**示例 3：**

```
输入：s = "()()"
输出：""
解释：
输入字符串为 "()()"，原语化分解得到 "()" + "()"，
删除每个部分中的最外层括号后得到 "" + "" = ""。
```

 

**提示：**

- `1 <= s.length <= 105`
- `s[i]` 为 `'('` 或 `')'`
- `s` 是一个有效括号字符串



##### 栈

```c++
class Solution {
 public:
  string removeOuterParentheses(string s) {
    string res = "";
    stack<char> Stack;  //使用栈表示括号的深度
    //遇到'('就入栈,遇到')'就出栈,,,栈从空到下一次为空的过程,也就是一个原语过程
    //每一个原语过程,取出首尾字符
    for (int i = 0; i < s.size(); i++) {
      if (s[i] == ')') {  //出栈
        Stack.pop();
      }
      if (!Stack.empty()) {
        //判断是否为空,排除一个原语过程中首位'('以及尾部')'的情况,否则的话如果是'('或者')'都加入到res
        res += s[i];
      }
      if (s[i] == '(') {  //深度为1的'('不加入到res,因为这必然是最外层的'('
        Stack.push('(');
      }
    }
    return res;
  }
};
```

##### 计数

> 将入栈出栈的操作简化为`level+1`或者`level-1`

```C++
class Solution {
 public:
  //将入栈出栈的操作简化为`level+1`或者`level-1`
  string removeOuterParentheses(string s) {
    string res = "";
    int level = 0;
    for (auto c : s) {
      if (c == ')') {
        level--;
      }
      if (level > 0) {
        res += c;
      }
      if (c == '(') {
        level++;
      }
    }
    return res;
  }
};
```

