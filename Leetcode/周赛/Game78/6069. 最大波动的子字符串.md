#### [6069. 最大波动的子字符串](https://leetcode.cn/problems/substring-with-largest-variance/)

难度困难6

字符串的 **波动** 定义为子字符串中出现次数 **最多** 的字符次数与出现次数 **最少** 的字符次数之差。

给你一个字符串 `s` ，它只包含小写英文字母。请你返回 `s` 里所有 **子字符串的** **最大波动** 值。

**子字符串** 是一个字符串的一段连续字符序列。

**示例 1：**

```
输入：s = "aababbb"
输出：3
解释：
所有可能的波动值和它们对应的子字符串如以下所示：
- 波动值为 0 的子字符串："a" ，"aa" ，"ab" ，"abab" ，"aababb" ，"ba" ，"b" ，"bb" 和 "bbb" 。
- 波动值为 1 的子字符串："aab" ，"aba" ，"abb" ，"aabab" ，"ababb" ，"aababbb" 和 "bab" 。
- 波动值为 2 的子字符串："aaba" ，"ababbb" ，"abbb" 和 "babb" 。
- 波动值为 3 的子字符串 "babbb" 。
所以，最大可能波动值为 3 。
```

**示例 2：**

```
输入：s = "abcde"
输出：0
解释：
s 中没有字母出现超过 1 次，所以 s 中每个子字符串的波动值都是 0 。
```

**提示：**

- `1 <= s.length <= 104`
- `s` 只包含小写英文字母。

#### 思路

> 字符集比较小，因此枚举字符对进而计算答案。
> 设`ch1`为最多字符，`ch2`为最少字符。
> `dp[0] `表示`连续ch1字符`的数量
> `dp[1] `表示`当前位置结尾的最大波动值`

#### Code

```java
 /*
        字符集比较小，因此枚举字符对进而计算答案。
        设ch1为最多字符，ch2为最少字符。
        dp[0] 表示连续ch1字符的数量
        dp[1] 表示当前位置结尾的最大波动值

     */
public int largestVariance(String s){
        int n=s.length(),res=0;
        //分别暴力枚举连续出现出现次数最多的字符ch1  出现次数最少的字符ch2
        for(char ch1='a';ch1<='z';ch1++){
        for(char ch2='a';ch2<='z';ch2++){
        if(ch1==ch2){//同一字符,,跳过
        continue;
        }
        //dp[0] 表示连续出现最多ch1字符的数量
        //dp[1] 表示当前位置结尾的最大波动值
        int[]dp={0,-114514};
        for(char c:s.toCharArray()){
        if(c==ch2){
        //dp[1]-1表示最大波动值-1,也就是说ch2任然是最少个数,ch1数量不变,ch2+1,因此最大波动-1
        //dp[0]-1表示连续出现最多ch1字符数量-1   也就是ch2不再是最少的个数,而是另外其他的字符
        //二者取最大值
        dp[1]=Math.max(dp[1]-1,dp[0]-1);
        dp[0]=0;//中断连续出现最多次数ch1字符
        }else if(c==ch1){
        //出现最多字符ch1次数+1
        dp[0]++;
        dp[1]++;
        }
        res=Math.max(res,dp[1]);
        }
        }
        }
        return res;
        }
        }
```
